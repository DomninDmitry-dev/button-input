#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/gpio.h>
#include <linux/delay.h>
#include <linux/interrupt.h>
#include <asm/irq.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/platform_device.h>
#include <linux/gpio/consumer.h>
#include <linux/of.h>
#include <linux/spinlock.h>
#include <linux/input.h>
#include <linux/input-polldev.h>

struct poll_btn_data {
	struct input_polled_dev *poll_dev;
	struct gpio_desc *btn;
	struct platform_device *pdev;
};

/*----------------------------------------------------------------------------*/
static void polled_btn_open(struct input_polled_dev *poll_dev)
{
	struct poll_btn_data *pdata = poll_dev->private;
	dev_info(&pdata->pdev->dev, "polled device opened()\n");
}
/*----------------------------------------------------------------------------*/
static void polled_btn_close(struct input_polled_dev *poll_dev)
{
	struct poll_btn_data *pdata = poll_dev->private;
	dev_info(&pdata->pdev->dev, "polled device closed()\n");
}
/*----------------------------------------------------------------------------*/
static void polled_btn_poll(struct input_polled_dev *poll_dev)
{
	struct poll_btn_data *pdata = poll_dev->private;
	input_report_key(poll_dev->input, BTN_0, gpiod_get_value(pdata->btn) & 1);
	input_sync(poll_dev->input);
	dev_info(&pdata->pdev->dev, "polled device()\n");
}
/*----------------------------------------------------------------------------*/
static int polled_btn_probe(struct platform_device *pdev)
{
	int ret = 0;
	struct poll_btn_data *pdata;
	struct input_polled_dev *poll_dev;
	struct input_dev *input_dev;

	dev_info(&pdev->dev, "Starting module\n");

	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
	if (!pdata) {
		dev_err(&pdev->dev, "Error mem <devm_kzalloc> \n");
		return -ENOMEM;
	}

	poll_dev = input_allocate_polled_device();
	if (!poll_dev){
		goto fail;
	}

	pdata->btn = devm_gpiod_get(&pdev->dev, "btn", GPIOD_IN);
	if (IS_ERR(pdata->btn)) {
		dev_err(&pdev->dev, "%s() unable to get led GPIO: %ld\n",
				__func__, PTR_ERR(pdata->btn));
		goto fail;
	}
	poll_dev->private = pdata;
	poll_dev->poll_interval = 200; // Poll every 200ms
	poll_dev->poll = polled_btn_poll;
	poll_dev->open = polled_btn_open;
	poll_dev->close = polled_btn_close;
	pdata->poll_dev = poll_dev;

	input_dev = poll_dev->input;
	input_dev->name = "Packt input pulled Btn";
	input_dev->dev.parent = &pdev->dev;

	/* Declare the events generated by this driver */
	set_bit(EV_KEY, input_dev->evbit);
	set_bit(BTN_0, input_dev->keybit); /* buttons */

	ret = input_register_polled_device(pdata->poll_dev);
	if (ret) {
		dev_err(&pdev->dev, "Failed to register input polled device\n");
		input_free_polled_device(poll_dev);
		goto fail;
	}

	pdata->pdev = pdev;
	platform_set_drvdata(pdev, pdata);
	return 0;

fail:
	devm_kfree(&pdev->dev, pdata);
	dev_err(&pdev->dev, "Probe fail!\n");
	return -1;
}
/*----------------------------------------------------------------------------*/
static int polled_btn_remove(struct platform_device *pdev)
{
	struct poll_btn_data *pdata = platform_get_drvdata(pdev);

	input_unregister_polled_device(pdata->poll_dev);
	input_free_polled_device(pdata->poll_dev);
	devm_kfree(&pdev->dev, pdata);
	dev_info(&pdev->dev, "Removing module\n");
	return 0;
}
/*----------------------------------------------------------------------------*/
static const struct of_device_id btn_dt_ids[] = {
    { .compatible = "opi,button-input" },
    { /* sentinel */ },
};

MODULE_DEVICE_TABLE(of, btn_dt_ids);

static struct platform_driver my_btn = {
		.probe = polled_btn_probe,
		.remove = polled_btn_remove,
        .driver = {
                .owner = THIS_MODULE,
                .name = "input-polled-button",
		        .of_match_table = of_match_ptr(btn_dt_ids),
        },
};

module_platform_driver(my_btn);
/*----------------------------------------------------------------------------*/
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Dmitry");
